This file is a merged representation of a subset of the codebase, containing files not matching ignore patterns, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching these patterns are excluded: cmake-build-debug/*
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

<additional_info>

</additional_info>

</file_summary>

<directory_structure>
.github/
  template/
    config.yml
  workflows/
    cmake.yml
dependencies/
  imgui-sfml/
    CMakeLists.txt
  sfml/
    CMakeLists.txt
  CMakeLists.txt
src/
  components/
    CMakeLists.txt
    Components.cpp
    Components.h
  entity/
    CMakeLists.txt
    Entity.cpp
    Entity.h
  entitymanager/
    CMakeLists.txt
    EntityManager.cpp
    EntityManager.h
  game/
    CMakeLists.txt
    Game.cpp
    Game.h
  shapes/
    CMakeLists.txt
    Shape.cpp
    Shape.h
  vec2/
    CMakeLists.txt
    Vec2.cpp
    Vec2.h
  CMakeLists.txt
  main.cpp
.gitignore
CMakeLists.txt
CONTRIBUTING.md
LICENSE
README.md
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="src/components/CMakeLists.txt">
add_library(components
    Components.cpp
    Components.h
)

target_link_libraries(components
    PRIVATE vec2
)

target_include_directories(components
    PUBLIC ${CMAKE_CURRENT_SOURCE_DIR}
    PRIVATE ${CMAKE_CURRENT_SOURCE_DIR}/..
)
</file>

<file path="src/components/Components.cpp">
//
// Created by Jorge Jimenez on 6/11/25.
//

#include "Components.h"
</file>

<file path="src/components/Components.h">
//
// Created by Jorge Jimenez on 6/11/25.
//

#pragma once

#include "../vec2/Vec2.h"
#include <SFML/Graphics.hpp>


class Component
{
public:
    bool exists = false;
};

class CTransform : public Component
{
public:
    Vec2f pos       = { 0.0, 0.0};
    Vec2f velocity  = { 0.0, 0.0};
    float angle     = 0;

    CTransform() = default;
    CTransform(const Vec2f & p, const Vec2f & v, const float a)
            : pos(p), velocity(v), angle(a) {}
};

class CShape : public Component
{
public:
    sf::CircleShape circle;

    CShape() = default;
    CShape(const float radius, size_t points, const sf::Color & fill, const sf::Color & outline, const float thickness)
    {
        circle.setFillColor(fill);
        circle.setOutlineColor(outline);
        circle.setOutlineThickness(thickness);

        // Set the origin to the center to radius, radius
        const sf::Vector2f center = { radius, radius };
        circle.setOrigin(center);
    }
};

class CCollision : public Component
{
public:
    float radius = 0;

    CCollision() = default;
    explicit CCollision(const float r)
        : radius(r) {}

};

class CScore : public Component
{
public:
    int score = 0;

    CScore() = default;
    explicit CScore(const int s)
        : score(s){}
};

class CLifespan : public Component
{
public:
    int lifespan = 0;
    int remaining = 0;

    CLifespan() = default;
    explicit CLifespan(const int totalLifespan)
        : lifespan(totalLifespan), remaining(totalLifespan){}
};

class CInput : public Component
{
public:
    bool up = false;
    bool left = false;
    bool right = false;
    bool down = false;
    bool shoot = false;

    CInput() = default;
};
</file>

<file path="src/entity/CMakeLists.txt">
add_library(entity
    Entity.cpp
    Entity.h
)

target_link_libraries(entity
    PRIVATE components
    PRIVATE sfml-graphics
)

target_include_directories(entity
    PUBLIC ${CMAKE_CURRENT_SOURCE_DIR}
    PRIVATE ${CMAKE_CURRENT_SOURCE_DIR}/..
)
</file>

<file path="src/entity/Entity.cpp">
//
// Created by Jorge Jimenez on 6/15/25.
//

// Template specializations would typically be here for component management
</file>

<file path="src/entity/Entity.h">
#pragma once

#include "../components/Components.h"
#include <string>
#include <tuple>

class EntityManager;

using ComponentTuple = std::tuple<
    CTransform,
    CShape,
    CCollision,
    CInput,
    CScore,
    CLifespan
>;

class Entity
{
    friend class EntityManager;

    ComponentTuple  components;
    bool            active = true;
    std::string     entityTag    = "dfault";
    size_t          entityId     = 0;

    Entity(const size_t id, std::string entityTag)
        : entityTag(std::move(entityTag)), entityId(id)
    {}

public:
    [[nodiscard]] bool isActive () const
    {
        return active;
    }

    void destroy()
    {
        active = false;
    }

    [[nodiscard]] size_t id() const
    {
        return entityId;
    }

    [[nodiscard]] const std::string& tag() const
    {
        return entityTag;
    }

    template <typename T>
    [[nodiscard]] bool has() const
    {
        return get<T>().exists;
    }

    template <typename T, typename... TArgs>
    T& add(TArgs&&... mArgs)
    {
        auto& component = get<T>();
        component = T(std::forward<TArgs>(mArgs)...);
        component.exists = true;
        return component;
    }

    template<typename T>
    [[nodiscard]] T& get()
    {
        return std::get<T>(components);
    }

    template<typename T>
    [[nodiscard]] const T& get() const
    {
        return std::get<T>(components);
    }

    template<typename T>
    void remove()
    {
        get<T>() = T();
    }
};
</file>

<file path="src/entitymanager/CMakeLists.txt">
add_library(entitymanager
    EntityManager.cpp
    EntityManager.h
)

target_link_libraries(entitymanager
    PRIVATE entity
    PRIVATE components
    PRIVATE sfml-graphics
)

target_include_directories(entitymanager
    PUBLIC      ${CMAKE_CURRENT_SOURCE_DIR}
    PRIVATE     ${CMAKE_CURRENT_SOURCE_DIR}/..
)
</file>

<file path="src/entitymanager/EntityManager.cpp">
//
// Created by Jorge Jimenez on 6/15/25.
//

// Empty implementation file as requested
</file>

<file path="src/entitymanager/EntityManager.h">
//
// Created by Jorge Jimenez on 6/15/25.
//

#pragma once

#include "Entity.h"
#include <vector>
#include <map>
#include <memory>

using EntityVec = std::vector<std::shared_ptr<Entity>>;


class EntityManager
{
    EntityVec                           entitiesList;
    EntityVec                           entitiesToAdd;
    std::map<std::string, EntityVec>    entityMap;
    size_t                              totalEntities = 0;

    void removeDeadEntities(EntityVec& vec)
    {
        //TODO: remove dead entities
    }

public:
     EntityManager() = default;
     void update()
     {
         // TODO: add entities from entitiesToAdd the proper location(s)
         //        - add them to the vector of all entities
         //        - add them to the vector inside the map, with the tag as a key
         // remove dead entities from hte vector of all entities
         removeDeadEntities(entitiesList);

         // remove dead entities from each vector in the entity map
         // c++20 way of iterating through [key, value] pairs in a map
         for (auto& [tag, entityVec] : entityMap)
         {
             removeDeadEntities(entityVec);
         }
     }

    std::shared_ptr<Entity> addEntity(const std::string& tag)
    {
        //create the entiry shared pointer
        auto entity = std::shared_ptr<Entity>(new Entity(totalEntities++, tag));

        // add it to the vec of all entities
        entitiesToAdd.push_back(entity);

        // add it to the entity map
        if (entityMap.find(tag) == entityMap.end())
        {
            entityMap[tag] = EntityVec();
        }

        return entity;
    }

    const EntityVec& getEntities()
    {
        return entitiesList;
    }

    const EntityVec& getEntities(const std::string& tag)
    {
        if (entityMap.find(tag) == entityMap.end())
        {
            entityMap[tag] = EntityVec();
        }
        return entityMap[tag];
    }

    const std::map<std::string, EntityVec>& getEntityMap()
    {
        return entityMap;
    }
};
</file>

<file path="src/game/CMakeLists.txt">
add_library(game
        Game.cpp
        Game.h
)

target_link_libraries(game
        PRIVATE entitymanager
        PRIVATE sfml-graphics
        PRIVATE vec2
        PRIVATE ImGui-SFML
)

target_include_directories(game
        PUBLIC      ${CMAKE_CURRENT_SOURCE_DIR}
        PRIVATE     ${CMAKE_CURRENT_SOURCE_DIR}/..
        PRIVATE     ${CMAKE_CURRENT_SOURCE_DIR}/imgui
)
</file>

<file path="src/game/Game.cpp">
#include "Game.h"
#include <iostream>
#include <imgui.h> // necessary for ImGui::*, imgui-SFML.h doesn't include imgui.h
#include <imgui-SFML.h> // for ImGui::SFML::* functions and SFML-specific overloads


Game::Game(const std::string &config)
    : m_text(m_font) // Initialize sf::Text with font reference - SFML 3 requires this
{
    init(config);
}

void Game::init(const std::string &path) {
    // TODO: read in config file here
    //       use the pre made PlayerConfig, EnemyConfig, BulletConfig variables

    // set up default window parameters
    m_window.create(sf::VideoMode(sf::Vector2u(1280, 720)), "Assignment 2");
    m_window.setFramerateLimit(60);

    // Load a font first
    if (!m_font.openFromFile("arial.ttf")) {
        // Try to load a common system font as fallback
        if (!m_font.openFromFile("/System/Library/Fonts/Helvetica.ttc")) {
            std::cerr << "Failed to load fonts!" << std::endl;
        }
    }
    
    // Configure text after font is loaded
    m_text.setString("Score: 0");
    m_text.setCharacterSize(30);

    if (!ImGui::SFML::Init(m_window)) {
        std::cerr << "Failed to initialize ImGui-SFML" << std::endl;
    }

    // scale the imgui ui and text size by 2
    ImGui::GetStyle().ScaleAllSizes(2.0f);
    ImGui::GetIO().FontGlobalScale = 2.0f;

    spawnPlayer();
}

void Game::run() {
    // TODO:
    // - add pause functionality in here
    // - some systems should function while paused (rendering)
    // - some systems shouldn't (movement / input)
    while (m_running)
    {
        // update the entity manager
        m_entities.update();

        // required update call to imgui
        ImGui::SFML::Update(m_window, m_deltaClock.restart());

        sEnemySpawner();
        sMovement();
        sCollision();
        sUserInput();
        sGUI();
        sRender();

        // increment the current frame
        // may need to be moved when pause implemented
        m_currentFrame++;
    }
}

void Game::setPaused(bool paused) {
    // TODO
}

// respawn the player in the middle of the screen
void Game::spawnPlayer() {
    // TODO: Finish adding all properties of the player with the correct values from config

    // We create every entity by calling EntityManager.addEntity(tag)
    // This returns a std::shared_ptr<Entity>, so we use 'auto' to save typing
    auto entity = m_entities.addEntity("player");

    // Give this entity a Transform, so it spawns at (200,200) with velocity (1,1) and angle 0
    entity->add<CTransform>(Vec2f(200.0f, 200.0f), Vec2f(1.0f, 1.0f), 0.0f);

    // The entity's shape will have radius 32, 8 sides, dark grey fill, and red outline of thickness 4
    entity->add<CShape>(32.0f, 8, sf::Color(10, 10, 10), sf::Color(255, 0, 0), 4.0f);

    // Add an input component to the player so that we can use inputs
    entity->add<CInput>();

    // Since we want this Entity to be our player, set our Game's player variable to be this Entity
    // This goes slightly against the EntityManager paradigm, but we use the player so much it's worth it
    m_player = entity;
}

// spawn an enemy at a random position
void Game::spawnEnemy() {
    // TODO:
    // make sure the enemy is spawned properly with the m_enemyConfig variables
    // the enemy must be spawned completely within the bounds of the window

    // auto e = m_entities.addEntity("enemy");
    // e->add<CTransform>(args);
    // e->add<CShape>(args);

    // record when the most recent enemy was spawned
    m_lastEnemySpawnTime = m_currentFrame;
}

// spawns the small enemies when a big one (input entity e) explodes
void Game::spawnSmallEnemies(std::shared_ptr<Entity> e) {
    // TODO: spawn small enemies at the location of the input enemy e

    // when we create the smaller enemy, we have to read the values of the original enemy
    // - spawn a number of small enemies equal to the vertices of the original enemy
    // - set each small enemy to the same color as the original, half the size
    // - small enemies are worth double points of the original enemy
}

// spawns a bullet from a given entity to a target location
void Game::spawnBullet(std::shared_ptr<Entity> entity, const Vec2f &target) {
    // TODO: implement the spawning of a bullet which travels toward target
    // - bullet speed is given as a scalar speed
    // - you must set the velocity by using formula in notes
}

void Game::spawnSpecialWeapon(std::shared_ptr<Entity> entity) {
    // TODO: implement your own special weapon
}

void Game::sMovement() {
    // TODO: implement all entity movement in this function
    // you should read the m_player->cInput component to determine if the player is moving
    // sample:
    for (auto e: m_entities.getEntities())
    {
        // if entity has transform component...
    }

    // Sample movement speed update
    if (m_player && m_player->has<CTransform>()) {
        auto& transform = m_player->get<CTransform>();
        transform.pos.x += transform.velocity.x;
        transform.pos.y += transform.velocity.y;
    }
}

void Game::sLifespan() {
    // TODO: implement all lifespan functionality
    //
    // for all entities
    // - if entity has no lifespan component, skip it
    // - if entity has > 0 remaining lifespan, subtract 1
    // - if it has lifespan and is alive scale its alpha channel properly
    // - if it has lifespan and its time is up destroy the entity
}

void Game::sCollision() {
    // TODO: implement all proper collisions between entities
    // be sure to use the collision radius, not the shape radius
    // sample
//    for (auto bullet: m_entities.getEntities("bullet")) {
//        for (auto m_entities: m_entities.getEntities()) {
//            //check collision
//        }
//        // we need another loop for small entities because small entities don't spawn further
//    }
}

void Game::sEnemySpawner() {
    // TODO: code which implements enemy spawning should go here
}

void Game::sGUI() {
    ImGui::Begin("Geometry Wars");

    ImGui::Text("Stuff Goes Here");

    ImGui::End();
}

void Game::sRender() {
    // TODO: change the code below to draw ALL of the entities
    // sample drawing of the player Entity that we have created
    m_window.clear();

    if (m_player && m_player->has<CShape>() && m_player->has<CTransform>()) {
        auto& shape = m_player->get<CShape>();
        auto& transform = m_player->get<CTransform>();
        
        // set the position of the shape based on the entity's transform->pos
        shape.circle.setPosition(sf::Vector2f(transform.pos.x, transform.pos.y));

        // set the rotation of the shape based on the entity's transform->angle
        transform.angle += 1.0f;
        // Use the sf::degrees function to convert float to sf::Angle
        shape.circle.setRotation(sf::degrees(transform.angle));

        // draw the entity's sf::CircleShape
        m_window.draw(shape.circle);
    }

    // draw the ui last
    ImGui::SFML::Render(m_window);

    m_window.display();
}

void Game::sUserInput() {
    // TODO: handle user input here
    // note that you should only be setting the player's input component variables here
    // you should not implement the player's movement logic here
    // the movement system will read the variables you set in this function

    // Handle events using SFML 3.0 API with std::optional
    std::optional<sf::Event> optEvent = m_window.pollEvent();
    
    while (optEvent) {
        const auto& event = *optEvent;
        
        // pass the event to imgui to be parsed
        ImGui::SFML::ProcessEvent(m_window, event);

        // Using the SFML 3.0 event handling API with is<T> and getIf<T> methods
        if (event.is<sf::Event::Closed>()) {
            m_running = false;
        }
        else if (const auto* keyEvent = event.getIf<sf::Event::KeyPressed>()) {
            if (keyEvent->scancode == sf::Keyboard::Scancode::W) {
                std::cout << "W Key Pressed\n";
                if (m_player && m_player->has<CInput>()) {
                    m_player->get<CInput>().up = true;
                }
            }
        }
        else if (const auto* keyEvent = event.getIf<sf::Event::KeyReleased>()) {
            if (keyEvent->scancode == sf::Keyboard::Scancode::W) {
                std::cout << "W Key Released\n";
                if (m_player && m_player->has<CInput>()) {
                    m_player->get<CInput>().up = false;
                }
            }
        }
        else if (const auto* mouseEvent = event.getIf<sf::Event::MouseButtonPressed>()) {
            // this line ignores mouse events if ImGui is the thing being clicked
            if (ImGui::GetIO().WantCaptureMouse) {
                optEvent = m_window.pollEvent();
                continue;
            }

            if (mouseEvent->button == sf::Mouse::Button::Left) {
                std::cout << "Left Mouse Button Clicked at(" << mouseEvent->position.x
                          << ", " << mouseEvent->position.y << ")\n";
                // TODO: call spawnBullet here
            }
            else if (mouseEvent->button == sf::Mouse::Button::Right) {
                std::cout << "Right Mouse Button Clicked at(" << mouseEvent->position.x
                          << ", " << mouseEvent->position.y << ")\n";
                // TODO: call special weapon here
            }
        }
        
        optEvent = m_window.pollEvent();
    }
}
</file>

<file path="src/game/Game.h">
#pragma once

#include <SFML/Graphics.hpp>
#include "../entitymanager/EntityManager.h"
#include "Vec2.h"

struct PlayerConfig{int SR, CR, FR, FG, FB, OR, OG, OB, OT, V; float S; };
struct EnemyConfig {int SR, CR, OR, OG, OB, OT, VMIN, VMAX, L, SI; float SMIN, SMAX;};
struct BulletConfig{int SR, CR, FR, FG, FB, OR, OG, OB, OT, V, L; float S; };

class Game
{
    sf::RenderWindow    m_window; // the window we are rendering to
    EntityManager       m_entities; // the entity manager
    sf::Font            m_font;   // the font
    sf::Text            m_text;   // the text to display the score
    PlayerConfig        m_playerConfig;
    EnemyConfig         m_enemyConfig;
    BulletConfig        m_bulletConfig;
    sf::Clock           m_deltaClock;
    int                 m_score = 0;
    int                 m_currentFrame = 0;
    int                 m_lastEnemySpawnTime = 0;
    bool                m_paused = false;
    bool                m_running = true;
    std::shared_ptr<Entity> m_player;

    void init(const std::string & config); // Initialize the game with a config file
    void setPaused(bool paused);

    void sMovement();
    void sUserInput();
    void sLifespan();
    void sRender();
    void sGUI();
    void sEnemySpawner();
    void sCollision();

    void spawnPlayer();
    void spawnEnemy ();
    void spawnSmallEnemies (std::shared_ptr<Entity> entity) ;
    void spawnBullet (std::shared_ptr<Entity> entity, const Vec2f & target);
    void spawnSpecialWeapon(std::shared_ptr<Entity> entity);

public:
    Game(const std::string & config);
    void run();
};
</file>

<file path="src/vec2/CMakeLists.txt">
add_library(vec2
    Vec2.cpp
    Vec2.h)

target_link_libraries(vec2
    sfml-graphics
)

target_include_directories(vec2
    PUBLIC ${CMAKE_CURRENT_SOURCE_DIR}
)
</file>

<file path="src/vec2/Vec2.cpp">
//
// Created by Jorge Jimenez on 6/11/25.
//

#include "Vec2.h"
</file>

<file path="src/vec2/Vec2.h">
//
// Created by Jorge Jimenez on 6/11/25.
//

#pragma once

#include <SFML/Graphics.hpp>
#include <cmath>

template<typename T>
class Vec2 {
public:
    T x = 0;
    T y = 0;

    /// Default constructor, sets x and y to 0
    Vec2() = default;
    /// Constructor with x and y values
    /// \param xin The x value to set
    /// \param yin The y value to set
    Vec2(T xin, T yin)
        : x(xin), y(yin) {}
    // Constructor to convert sf::Vector2f to Vec2
    Vec2(const sf::Vector2f vec)
        : x(vec.x), y(vec.y) {}

    // allow automatic conversion to sf::Vector2
    // this lets us pass Vec2 in sfml fucntions
    operator sf::Vector2<T>()
    {
        return sf::Vector2<T>(x, y);
    }

    Vec2 operator + (const Vec2& rhs) const
    {
        return Vec2(x + rhs.x, y + rhs.y);
    }

    Vec2 operator - (const Vec2& rhs) const
    {
        return Vec2(x - rhs.x, y - rhs.y);
    }

    Vec2 operator / (const T val) const
    {
        return Vec2(x / val, y / val);
    }

    Vec2 operator * (const T val) const
    {
        return Vec2(x * val, y * val);
    }

    bool operator == (const Vec2& rhs) const
    {
        return x == rhs.x && y == rhs.y;
    }

    bool operator != (const Vec2& rhs) const
    {
        return !(x == rhs.x && y == rhs.y);
    }

    void operator += (const Vec2& rhs)
    {
        x += rhs.x;
        y += rhs.y;
    }

    void operator -= (const Vec2& rhs)
    {
        x -= rhs.x;
        y -= rhs.y;
    }

    void operator *= (const T val)
    {
        x *= val;
        y *= val;
    }

    void operator /= (const T val)
    {
        x /= val;
        y /= val;
    }

    float dist(const Vec2& rhs) const
    {
        return sqrt((x - rhs.x) * (x - rhs.x) + (y - rhs.y) * (y - rhs.y));
    }
};

using Vec2f = Vec2<float>;
</file>

<file path=".github/template/config.yml">
# GitHub repository template configuration
blank_issues_enabled: true
contact_links:
  - name: Question or Discussion
    url: https://github.com/yourusername/CMakeLearn/discussions
    about: Ask questions and discuss with other community members
</file>

<file path="dependencies/imgui-sfml/CMakeLists.txt">
message(STATUS "Fetching ImGui-SFML...")

set(IMGUI_DIR ${imgui_SOURCE_DIR})
set(IMGUI_SFML_FIND_SFML OFF)
set(IMGUI_SFML_IMGUI_DEMO ON)

FetchContent_MakeAvailable(imgui-sfml)
</file>

<file path="dependencies/sfml/CMakeLists.txt">
message(STATUS "Fetching SFML")

# No need to build audio and network modules
#set(SFML_BUILD_AUDIO OFF)
#set(SFML_BUILD_NETWORK OFF)

FetchContent_MakeAvailable(SFML)
</file>

<file path="dependencies/CMakeLists.txt">
include(FetchContent)

# SFML
FetchContent_Declare(
        SFML
        GIT_REPOSITORY https://github.com/SFML/SFML.git
        GIT_TAG 3.0.1
        GIT_SHALLOW ON
        EXCLUDE_FROM_ALL
        SYSTEM)
FetchContent_MakeAvailable(SFML)

# IMGUI
FetchContent_Declare(
        imgui
        GIT_REPOSITORY https://github.com/ocornut/imgui.git
        GIT_TAG v1.91.9b
)
# IMGUI does not have a cmake file, so we need to add it manually and build it.
FetchContent_MakeAvailable(imgui)

# IMGUI-SFML
FetchContent_Declare(
        imgui-sfml
        GIT_REPOSITORY https://github.com/SFML/imgui-sfml.git
        GIT_TAG v3.0
)
add_subdirectory(imgui-sfml)
</file>

<file path="src/shapes/CMakeLists.txt">
# Define the shapes library
add_library(shapes 
    Shape.cpp 
    Shape.h
)

# Link with necessary libraries
target_link_libraries(shapes
    PUBLIC sfml-graphics
)

# Include directories
target_include_directories(shapes
    PUBLIC ${CMAKE_CURRENT_SOURCE_DIR}
)
</file>

<file path="src/shapes/Shape.cpp">
//
// Created by Jorge Jimenez on 6/3/25.
//

#include "Shape.h"

namespace cmakelearn {

Shape::Shape() : mShape(100.f) {
    mShape.setFillColor(sf::Color::Green);
    mShape.setOutlineColor(sf::Color::White);
    mShape.setOutlineThickness(2.f);
    mShape.setPosition(sf::Vector2f(0.f, 0.f));
}

Shape::~Shape() = default;

void Shape::setPosition(float x, float y) {
    mShape.setPosition(sf::Vector2f(x, y));
}

void Shape::setFillColor(const sf::Color& color) {
    mShape.setFillColor(color);
}

void Shape::setOutlineColor(const sf::Color& color) {
    mShape.setOutlineColor(color);
}

void Shape::setOutlineThickness(float thickness) {
    mShape.setOutlineThickness(thickness);
}

void Shape::draw(sf::RenderTarget& target, sf::RenderStates states) {
    target.draw(mShape, states);
}

} // namespace cmakelearn
</file>

<file path="src/shapes/Shape.h">
//
// Created by Jorge Jimenez on 6/3/25.
//

#ifndef CMAKELEARN_SHAPE_H
#define CMAKELEARN_SHAPE_H

#include <SFML/Graphics.hpp>

namespace cmakelearn {

class Shape {
public:
    Shape();
    ~Shape();
    
    // Set the position of the shape
    void setPosition(float x, float y);
    
    // Set the fill color of the shape
    void setFillColor(const sf::Color& color);
    
    // Set the outline color of the shape
    void setOutlineColor(const sf::Color& color);
    
    // Set the outline thickness
    void setOutlineThickness(float thickness);
    
    // Draw the shape to a render target
    void draw(sf::RenderTarget& target, sf::RenderStates states = sf::RenderStates::Default);
    
private:
    sf::CircleShape mShape;
};

} // namespace cmakelearn

#endif // CMAKELEARN_SHAPE_H
</file>

<file path=".gitignore">
# CMake build directories
build/
cmake-build-*/
CMakeFiles/
CMakeScripts/
CMakeCache.txt
cmake_install.cmake

# Compiled Object files
*.o
*.obj
*.lo
*.slo

# Precompiled Headers
*.gch
*.pch

# Compiled Dynamic libraries
*.so
*.dylib
*.dll

# Compiled Static libraries
*.a
*.la
*.lai
*.lib

# Executables
*.exe
*.out
*.app

# IDE specific files
.idea/
.vscode/
*.swp
*.swo
.vs/
*.suo
*.user
*.userosscache
*.sdf
*.opensdf
*.VC.db
*.VC.opendb
*.xcodeproj/
*.xcworkspace/
xcuserdata/

# Debug files
*.dSYM/
*.su
*.idb
*.pdb

# macOS specific
.DS_Store
.AppleDouble
.LSOverride
._*

# Generated files
Testing/
DartConfiguration.tcl
install_manifest.txt
compile_commands.json
CTestTestfile.cmake
*_autogen/

# Dependencies fetched via FetchContent
_deps/
</file>

<file path="CMakeLists.txt">
cmake_minimum_required(VERSION 3.28)
project(
    CMakeLearn
    VERSION 1.0
    DESCRIPTION "CMakeLearn"
    LANGUAGES CXX
)

set(CMAKE_CXX_STANDARD 17)
add_subdirectory(./dependencies)
add_subdirectory(./src)
</file>

<file path="CONTRIBUTING.md">
# Contributing to CMakeLearn

Thank you for your interest in contributing to this project! Here's how you can help:

## Development Setup

1. Fork and clone the repository
2. Configure the project with CMake:
```bash
mkdir -p build && cd build
cmake ..
```
3. Build the project:
```bash
cmake --build .
```

## Guidelines

- Follow the existing code style and conventions
- Write clear commit messages
- Include tests for new features
- Update documentation when necessary

## Pull Request Process

1. Ensure your code builds and tests pass
2. Update the README.md with details of changes if appropriate
3. Submit your pull request with a clear description of the changes

Your contributions are greatly appreciated!
</file>

<file path="LICENSE">
MIT License

Copyright (c) 2025 Your Name

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
</file>

<file path="src/CMakeLists.txt">
# Add subdirectories
add_subdirectory(shapes)
add_subdirectory(vec2)
add_subdirectory(components)
add_subdirectory(entity)
add_subdirectory(entitymanager)
add_subdirectory(game)

# Main executable
add_executable(CMakeLearn main.cpp)

# Link with dependencies
# The PRIVATE keyword specifies that the libraries are only used by the
# CMakeLearn target and are not propagated to its dependents.
#
# ImGui-SFML is a dependency of CMakeLearn, which means that any target that
# links to CMakeLearn will also link to ImGui-SFML.
#
# The shapes library is also a dependency of CMakeLearn, and is linked to
# privately, which means that it is not propagated to targets that link to
# CMakeLearn.
target_link_libraries(CMakeLearn
        PRIVATE ImGui-SFML::ImGui-SFML
        PRIVATE shapes
        PRIVATE vec2
        PRIVATE components
        PRIVATE entity
        PRIVATE entitymanager
        PRIVATE game
)

# Apply the same compiler warnings as ImGui-SFML
#
# The PRIVATE keyword specifies that the compiler options are only applied to
# the CMakeLearn target and are not propagated to its dependents.
target_compile_options(CMakeLearn PRIVATE ${IMGUI_SFML_WARNINGS})
</file>

<file path="src/main.cpp">
#include <SFML/Graphics.hpp>
#include "Game.h"
#include "shapes/Shape.h"
#include "vec2/Vec2.h"

#include <iostream>
#include <iomanip>
#include <string>
#include <functional>
#include <vector>

int main()
{
    Game game("config.json");
    game.run();
    return 0;
}
</file>

<file path=".github/workflows/cmake.yml">
name: CMake Build

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]

jobs:
  build:
    name: ${{ matrix.config.name }}
    runs-on: ${{ matrix.config.os }}
    strategy:
      fail-fast: false
      matrix:
        config:
          - {
            name: "Windows Latest MSVC",
            os: windows-latest,
            build_type: "Release",
            cc: "cl",
            cxx: "cl",
            generators: "Visual Studio 17 2022"
          }
          - {
            name: "Ubuntu Latest GCC",
            os: ubuntu-latest,
            build_type: "Release",
            cc: "gcc",
            cxx: "g++",
            generators: "Ninja"
          }
          - {
            name: "macOS Latest Clang",
            os: macos-latest,
            build_type: "Release",
            cc: "clang",
            cxx: "clang++",
            generators: "Ninja"
          }

    steps:
    - uses: actions/checkout@v3

    - name: Install dependencies (Ubuntu)
      if: startsWith(matrix.config.os, 'ubuntu')
      run: |
        sudo apt-get update
        sudo apt-get install -y libxrandr-dev libxcursor-dev libudev-dev libopenal-dev libflac-dev libvorbis-dev libgl1-mesa-dev libegl1-mesa-dev ninja-build libxi-dev libfreetype-dev

    - name: Install dependencies (macOS)
      if: startsWith(matrix.config.os, 'macos')
      run: |
        brew install ninja

    - name: Install dependencies (Windows)
      if: startsWith(matrix.config.os, 'windows')
      run: |
        choco install ninja

    - name: Configure CMake
      run: >
        cmake -S . -B build
        -DCMAKE_BUILD_TYPE=${{matrix.config.build_type}}
        -G "${{matrix.config.generators}}"
        -DCMAKE_C_COMPILER=${{matrix.config.cc}}
        -DCMAKE_CXX_COMPILER=${{matrix.config.cxx}}

    - name: Build
      run: cmake --build build --config ${{matrix.config.build_type}}
</file>

<file path="README.md">
# CMakeLearn - SFML and ImGui Template

A modern C++ project template using CMake, SFML 3.0, and ImGui integration.

## Features

- Modern CMake (3.28+) configuration
- SFML 3.0.1 integration with automatic dependency management
- Dear ImGui integration with SFML
- Cross-platform support (Windows, macOS, Linux)
- Basic example demonstrating window creation, event handling, and UI

## Requirements

- CMake 3.28 or higher
- C++17 compatible compiler
- Git

### Platform-Specific Dependencies

#### Ubuntu/Debian Linux
```bash
sudo apt-get update
sudo apt-get install -y libxrandr-dev libxcursor-dev libudev-dev libopenal-dev libflac-dev libvorbis-dev libgl1-mesa-dev libegl1-mesa-dev libxi-dev libfreetype-dev
```

#### macOS
No additional dependencies required if you have Xcode installed.

#### Windows
No additional dependencies required if you have Visual Studio installed.

## Quick Start

```bash
# Clone this template
git clone https://github.com/yourusername/CMakeLearn.git
cd CMakeLearn

# Create build directory
mkdir -p build && cd build

# Configure and build
cmake ..
cmake --build .

# Run the application
./src/CMakeLearn
```

## Project Structure

```
CMakeLearn/
├── .github/            # GitHub-specific files (workflows, etc.)
├── cmake/              # CMake modules and utilities
├── dependencies/       # External dependencies configuration
├── src/                # Source code
│   ├── main.cpp        # Application entry point
│   ├── Shape.h         # Example shape class
│   └── Shape.cpp       # Implementation
├── .gitignore          # Git ignore rules
├── CMakeLists.txt      # Main CMake configuration
├── LICENSE             # License information
└── README.md           # This file
```

## Customizing the Template

After using this template:

1. Update the project name in the root `CMakeLists.txt`
2. Modify the application in `src/main.cpp`
3. Add your own classes and files to the `src` directory
4. Update this README.md with your project information

## License

This template is available under the MIT License. See the LICENSE file for details.
</file>

</files>
